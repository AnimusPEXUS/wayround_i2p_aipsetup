
"""
XML info files manipulations.

Print, read, write, fix info files.
"""

import os.path
import copy
import glob
import logging

import lxml.etree

from mako.template import Template


import org.wayround.utils.file
import org.wayround.utils.edit

import org.wayround.aipsetup.config
import org.wayround.aipsetup.name


SAMPLE_PACKAGE_INFO_STRUCTURE = dict(
    # not required, but can be useful
    homepage="",
    # description
    description="",
    # 'standard', 'local' or other package name
    pkg_name_type="",
    # string list
    tags=[],
    # string
    buildinfo=''
    )

pkg_info_file_template = Template(text="""\
<package>

  <!-- This file is generated by aipsetup -->

  <!-- Name type can be one of:
    * ${ name_type_list }.
  -->
  <nametype value="${ pkg_name_type | x}" />

  <description>${ description | x}</description>
  <homepage url="${ homepage | x}" />

  % if len(tags) == 0:
  <!-- Use <tag name="" /> constructions for listing
       tags -->
  % endif
  % for i in tags:
  <tag name="${ i | x}" />
  % endfor

  <buildinfo value="${ buildinfo | x }" />

</package>
""")



def exported_commands():
    return {
        'mass_info_fix': info_mass_info_fix,
        'list': info_list_files,
        'edit': info_edit_file,
        'editor': info_editor,
        'copy': info_copy
        }

def commands_order():
    return [
        'editor',
        'list',
        'edit',
        'copy',
        'mass_info_fix'
        ]

def info_list_files(opts, args, typ='info', mask='*.xml'):
    """
    List XML files in pkg_info dir of UNICORN dir

    [FILEMASK]

    One argument is allowed - FILEMASK, which defaults to '*.xml'

    example:
    aipsetup info list '*doc*.xml'
    """

    args_l = len(args)

    if args_l > 1:
        logging.error("Too many arguments")
    else:

        if args_l == 1:
            mask = args[0]

        org.wayround.utils.file.list_files(
            org.wayround.aipsetup.config.config[typ], mask
            )

    return 0

def info_edit_file(opts, args, typ='info'):
    """
    Edit selected info-file in editor designated in aipsetup.conf

    FILENAME

    One argument required - FILENAME
    """
    ret = 0
    if len(args) != 1:
        logging.error("file to edit not specified")
        ret = 1
    else:
        ret = org.wayround.utils.edit.edit_file(
            os.path.join(
                org.wayround.aipsetup.config.config[typ],
                args[0]
                ),
            org.wayround.aipsetup.config.config['editor']
            )
    return ret

def info_editor(opts, args):
    """
    Start special info-file editor
    """
    import org.wayround.aipsetup.infoeditor

    org.wayround.aipsetup.infoeditor.main()

    return 0

def info_copy(opts, args):
    """
    Creates a copy of one info file into another

    OLDNAME NEWNAME
    """
    if len(args) != 2:
        logging.error("wrong argument count")
    else:

        org.wayround.utils.file.inderictory_copy_file(
            org.wayround.aipsetup.config.config['info'],
            args[0],
            args[1]
            )

    return 0

def info_mass_info_fix(opts, args):

    lst = glob.glob(os.path.join(org.wayround.aipsetup.config.config['info'], '*.xml'))

    lst_c = len(lst)
    lst_i = 0

    for i in lst:

        name = os.path.basename(i)[:-4]

        dicti = read_from_file(i)

        info_fixes(dicti, name)

        write_to_file(i, dicti)

        lst_i += 1

        org.wayround.utils.file.progress_write("    {:3.0f}% ({}/{})".format(100.0 / (lst_c / lst_i), lst_c, lst_i))

    logging.info("Processed %(n)d files" % {
        'n': len(lst)
        })

    return 0


def _find_latest(tree, tag, field):
    y = None
    x = tree.findall(tag)
    if len(x) > 0:
        y = x[-1].get(field)
    return y

def _find_list(tree, tag, field):
    y = []
    x = tree.findall(tag)
    lx = len(x)
    for i in range(lx):
        z = x[i].get(field)
        if isinstance(z, str):
            y.append(z)
    return y


def is_info_dicts_equal(d1, d2):

    ret = True

    for i in ['pkg_name_type', 'buildinfo',
              'homepage', 'description']:
        if d1[i] != d2[i]:
            ret = False
            break

    if ret:
        for i in ['tags']:

            if ret:
                for each in d1[i]:
                    if not each in d2[i]:
                        ret = False
                        break

            if ret:
                for each in d2[i]:
                    if not each in d1[i]:
                        ret = False
                        break

            if not ret:
                break

    return ret

def read_from_file(name):
    ret = None

    txt = ''
    tree = None

    try:
        f = open(name, 'r')
    except:
        logging.exception("Can't open file %(name)s" % {
            'name': name
            })
    else:
        try:
            txt = f.read()

            try:
                tree = lxml.etree.fromstring(txt)
            except:
                logging.exception("Can't parse file `%(name)s'" % {
                    'name': name
                    })
                ret = 2
            else:
                ret = copy.copy(SAMPLE_PACKAGE_INFO_STRUCTURE)

                for i in ['buildinfo']:
                    x = _find_latest(tree, i, 'value')
                    if x != None:
                        ret[i] = x

                x = _find_latest(tree, 'nametype', 'value')
                if x != None:
                    ret['pkg_name_type'] = x

                x = _find_latest(tree, 'homepage', 'url')
                if x != None:
                    ret['homepage'] = x

                x = tree.findall('description')
                if len(x) > 0:
                    ret['description'] = x[-1].text

                ret['tags'] = _find_list(tree, 'tag', 'name')

                ret['tags'].sort()
                del(tree)
        finally:
            f.close()

    return ret

def write_to_file(name, struct):

    ret = 0

    struct['tags'].sort()

    lst = copy.copy(org.wayround.aipsetup.name.NAME_REGEXPS_ORDER)
    lst.sort()

    txt = pkg_info_file_template.render(
        pkg_name_type=struct['pkg_name_type'],
        description=struct['description'],
        homepage=struct['homepage'],
        tags=struct['tags'],
        buildinfo=struct['buildinfo'],
        name_type_list=';\n    * '.join(lst)
        )

    try:
        f = open(name, 'w')
        f.write(txt)
        f.close()
    except:
        logging.exception("Can't rewrite file %(name)s" % {
            'name': name
            })
        ret = 1

    return ret

def info_fixes(dicti, name):
    """
    This function is used by `info_mass_info_fix'

    Sometime it will contain checks and fixes for
    info files
    """

    if dicti['pkg_name_type'] == 'standard':

        pass

